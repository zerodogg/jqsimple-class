=head1 NAME

jQsimple-class plugins

=head1 INTRODUCTION

In order to use a jQsimple-class plugin, simply load it after you
have loaded jQsimple-class.

=head1 jqsc-inlineExtend.js

This plugins provides an I<.jClass.inlineExtend()> statement that you
can use on classes.

=head2 DESCRIPTION AND USAGE

I<inlineExtend> allows you to add methods to a class without having to
create a whole new class that extends the parent, essentially plugging
your new methods into the parent. This has a few (delibarate) limitations:
  1. You can't add or override a constructor
  2. You can't replace existing methods

Example:
  myClass.jClass.inlineExtend({
      method4: function ()
      {
      }
  });

Any new instances of 'myClass' will now have the method4 method
available.

You can also use I<inlineExtend> to add methods from virtual classes,
the same restrictions apply.

I<inlineExtend> always returns I<.jClass>, so it is possible to chain
multiple inlineExtend calls after each other. Example:

	myClass.jClass.inlineExtend(virtualClass1).inlineExtend(virtualClass2);

=head1 PLUGIN API

Writing jQsimple-class plugins is quite simple, and access to append methods
both to the core jClass object, as well as classes generated is provided.

If you want to add methods to the core jClass object, simply set them on the
jClass object. If you want to add methods that will be available from
classes built using jQsimple-class, add them to jClass.constMethods.

jQsimple-class works in both a browser and in a commonjs (ie. node.js)
environment, so your plugin should too (if possible). To make this easy,
instead of working on jClass, include the following boilerplate code
at the top of your plugin:

	var jClassO; try { jClassO = jClass; } catch(err) { jClassO = global.jClass };

And then perform the actions on jClassO. That will always be available,
no matter which environment the plugin is being executed in.
